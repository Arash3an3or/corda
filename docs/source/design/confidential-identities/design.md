# Anonymous key mapping (Confidential identities changes)

## Overview

We are proposing a change to the identity service and key management services
to simplify the use of "confidential identities" (otherwise known as mapping
public keys to `Party`s) by:

* replacing the use of certificate chains with signed mappings of public
  keys to `Party`s

* eliminate the need for an `IdentityServiceInternal` interface

The key motivation driving these changes is the accounts feature which is
due to be released in Corda 5.

We would like the design review board to review our proposed changes detailed
in this document and also review a PoC which has been put together by Will
Hester that implements the changes described in this document.

The intention is that we will target Corda 5 with these changes.

## Background

The "Confidential identities" feature was introduced so that node operators
could create new key pairs on a per transaction basis instead of repeatedly
using the "legal identity" key, which is well known. Inside transactions,
only public keys would be stored, instead of a public key and x500 name,
thus anonymising state participation.

In order for parties to gain assurance that they are transacting with the
correct counter-party keys, certificate chains -- which prove "ownership"
of a key to a node -- are created with each newly generated key pair and
shared with counter-parties.

With the certificate chain stored for a particular public key, node operators
can look-up which `Party` "owns" that key. This is required to check the
intended keys are being used.

### Simplification needed

The identity service code requires simplification:

Currently there are two identity service interfaces `IdentityService` and
`IdentityServiceInternal`. `IdentityService` is intended to be used by CorDapp
developers and `IdentityServiceInternal` is used by the current "confidential
identities" feature. Both interfaces can be merged together, simplifying
the API.

The `PersistentIdentityService` and `InMemoryIdentityService` both contain
two maps:

1. `keysToParties` which is a mapping of `PublicKey` hash to the `Party`
   object for the legal/operator identity of a node.

2. `principalToParties` which maps an x500 name to a legal/operator
   identity.

Both maps are updated via the network map cache when a new `Party` is added
to the network and when a new "confidential identity" is created.

The network map driven updates to both maps are required. However, the updates
created to `principalToParties` when a new confidential identity is created
are unnecessary and shouldn't happen.

### Unnecessary use of x.509 certificates

The confidential identities feature uses certificate chains when there is
no need for it to. Numerous customers have asked that we implement C/Is
without the PKI paraphernalia, which wastes space and increases the complexity
of the feature.

Furthermore, one of the objectives of the engineering team off-site was
to de-couple the node's identity from signing identities. With the current
model, there is an underlying assumption that all keys generated by a node
are for a single "legal identity" (and the current implementation of "confidential
identities" also implies this. However, this does not reflect likely real-world
deployments where only sufficiently "advanced" end-users will operate Corda
nodes. All other users will likely be using a Corda as a service whereby
a node operator hosts "accounts" for its users.

## Goals

* Deprecate the old certificate based APIs and remove mention of them from
  the docs.

* Add new simpler APIs which allow CorDapp developers to generate, verify
  and store signed mappings of public keys to x500 names.

* Write a new set of flows to request and share signed mappings of public
  keys to x500 names

* Document the new APIs.

* Refactor the identity management and key management services so that they
  are easier to understand and maintain.

* De-couple signing identities from the node operators identity.

## Non-goals

Accounts will be tackled as part of a separate piece of work, as will the
new "CI" flows.

## Timeline

1. DONE Figure out a rough approach.

2. DONE Write a PoC.

3. DONE Formalise a design.

4. DONE Get design reviewed by the DRB.

5. TODO Implement the design using the PoC as a basis.

6. TODO Review and merge the work for Corda 5.

## Requirements

Requirements for anonymous key mappings:

1. CorDapp developers need to be able to register that a public key is mapped
   to a particular node (`Party`). Both the node which creates the key and
   the `Party` which requested the key must be able to store the mapping.

2. Many keys should be mappable to one `Party` but many parties cannot be
   mapped to one key.

3. The party registering the key must be confident that the key has originated
   from the claimed node operator, otherwise messages may be routed to the
   wrong node or assets might be moved to incorrect keys, due to error or
   malicious intent.

4. Nodes must to be able to generate key pairs for multiple purposes;

   1. The node operator is a single legal identity and they wish to generate
      a new key pair ( or confidential identity) to transact with.

   2. The the node operator hosts accounts on behalf of its customers. As
      such, the node operator will need to generate a "Default" key pair
      for each account (the "account key") and further key pairs if an account
      wishes to use a "confidential identity" and not continually have their
      account key associated with their states.

5. Nodes must be able to lookup the `Party` for `AnonymousParty`s (i.e.
   just a `PublicKey`) that have an associated mapping. Nodes must be able
   to perform lookups for their own keys as well as other node's keys.

Use-cases:

1. Regular "confidential identities" as they are known today. This assumes
   a set up where the node operator is also the "legal identity" of the
   node and this legal identity wishes to partake in transactions using
   a public key other than their legal identity key.

2. Accounts. A minimum of one key pair must be associated with each account
   but it is more likely that multiple key pairs will be associated with
   a single account. Those key pairs should not be attributed to a single
   "legal identity" but instead the keys need to be mapped to a node operator
   so that their counterparties know where to route messages.

Assumptions:

1. Internal threats. Our threat model doesn't cover internal threats, so
   for the time being, the stored data structure which maps a `PublicKey`
   to a `Party` object is not signed.

## Design

### Data model & serialization impact and changes required.

No changes.

### Public API, backwards compatibility impact.

#### New public types

    @CordaSerializable
    data class OwnershipClaim(val nonce: OpaqueBytes, val key: PublicKey)

The new type `OwnershipClaim` simply stores the `PublicKey` of the confidential identity. It is to be wrapped with `SignedData<T>` when the data is to be parsed by the new flows. 
object. The type makes no assumptions about _who_ the `PublicKey` is for.
Indeed, it could be for an account or a legal identity, if a company wishes
to self-host Corda. The `SignedData<OwnershipClaim>` should be signed by a node operator's
"legal identity" key only.

The `SignedData<OwnershipClaim>` is intended to be:

1. Returned by the `KeyManagementService` when a particular method
   is called to generate a new signed `PublicKey`.

2. The `PublicKey` and `Party` objects will be extracted before being consumed by the `IdentityService` to register a new the mapping between the `PublicKey` and `Party`.

It is unlikely that CorDapp developers will use these types directly. Instead,
there will be a set of flows for:

1. Requesting another node generate a new key pair then share a `SignedData<OwnershipClaim>`.

2. Generating a new key pair, then sharing a `SignedData<OwnershipClaim>` with
   another node.

####  `KeyManagementService` changes

`KeyManagementService` interface and implementation changes:

1. Deprecate `freshKeyAndCert` methods because they are not required any
   more. Instead, CorDapp developers will use a new method which returns
   a `SignedKeyForAccount`.

2. Add a new API called `fun freshKey(externalID: UUID): PublicKey`
   which creates a new key pair, adds an entry to the `PublicKeyHashToExternalId`
   entity (if an externalId is specified) and returns the `PublicKey`.
   **Note:** that the `PublicKey` must be registered with the `IdentityService`
   separately. Failing to do this will result in your node being unable
   to resolve `AnonymousParty` objects to `Party` objects for unregistered
   `PublicKey` to `Party` mappings.

#### `PersistentIdentityService` changes

1. Retain the existing mappings; `principalToParties` and `keysToParties`
   as the data they contain serves the existing APIs. Deprecate the old
   APIs:

   1. `IdentityService.verifyAndRegisterIdentity`
   2. `IdentityServiceInternal.justVerifyAndRegisterIdentity`
   3. `IdentityServiceInternal.verifyAndRegisterIdentity` (all overloads)
   4. `IdentityServiceInternal.registerIdentity`
   
2. Rename the existing mappings to better describe their contents:
    
   1. `keysToParties` will now be called `keyToPartyAndCert`
   2. `principalToParties` will now be called `nameToKey`

3. Add a new `AppendOnlyPersistentMap` called `keyToName` which
   should contain **all** public keys hashes mapped to the x500 name of
   the node where it is associated with. All legal identity keys as well
   as newly created anonymous keys should be stored in this map.


#### `IdentityService` changes

These points detail changes which must be made to ensure backwards compatible
behaviour whilst supporting a new API for key to party mappings:

1. Add a new method to `IdentityService` (and implementation in
   `PersistentIdentityService` and `InMemoryIdentityService`).

        fun registerKeyToParty(key: PublicKey, party: Party)

   This method only updates the `keyToName` mapping. If a mapping has already 
   been stored for the same `Party` then the method call is idempotent.
   If it turns out that another x500 name has been stored for the same key
   then the method will throw an exception for now. In the future, it might
   be the case that client-side generated key pairs can moved from one node
   to another or potentially used on multiple nodes. This work is out of
   scope for now - so the API will enforce that a public key can only ever
   be associated with a single x500 name.

2. `verifyAndRegisterIdentity` should now only be called by the network
   map cache (and any old CorDapps). Registering new public key to party
   mappings (or "confidential identities") should be done using the new
   method outlined above. As such this will be deprecated (see above).

3. `certificateFromKey` should return the `PartyAndCertificate` for
   any supplied `PublicKey`. This will require multiple map look-ups:

    1. On `keyToName`: `PublicKey` hash -> x500Name
    2. On `nameToKey`: x500Name -> legal identity `PublicKey`
    3. On `keyToPartyAndCert`: legal identity `PublicKey` to `PartyAndCertificate`

   Essentially we are trading performing an extra map lookup to storing
   the certificate chain for each confidential identity. Unfortunately we
   must store the certificate chains to preserve backwards compatibility,
   so the 3 map lookups are unavoidable.

4. `partyFromKey` should behave in the same way as `certificateFromKey`
   in that it should map "confidential identity" keys to `PartyAndCertificate`

5. `wellKnownPartyFromAnonymous` should work in the same way as `certificateFromKey`
   and `partyFromKey`.

Other methods shouldn't require any changes.

### Infrastructure services: persistence (schemas), messaging.

Adding a new hibernate entity which provides persistence for the `keyToPartyMapping`
append only persistent map.

### Impact on performance, scalability, high availability.

These changes should impact performance positively:

* Less disk space required for each newly generated key pair, as they
  are just stored as a public key hash to x500 name mapping in the
  `IdentityService`.
* Less heap space required as only one cert chain is stored for each
  legal identity key, as opposed to one cert chain _per_ key.
* We perform one extra map look-up for key to X look-ups on the `IdentityService`
  but as all this data is cached, the extra lookup shouldn't have a huge
  impact on performance.

### Versioning, upgradability, migration.

A database migration script will be required to populate the new hibernate
entity which backs the `keyToName` mapping. The existing "confidential identity"
mappings in the `keyToPartyAndCert` entity must be copied to the `keyToName`
entity.

### UI requirements, if any. Illustrate with UI Mockups and/or wireframes.

Keys with no mapping must be rendered using `toStringShort` on the public key.
Keys with mappings to an x500name can be rendered used the x500 name.

#### Flows

A new security protocol will be implemented to within the new flows. We introduce
a ``ChallengeResponse`` type which is an alias for ``SecureHash.SHA256``. This will
be randomly generated and used to prevent against replay attacks.

Two new flows will be added:

1. `RequestKeyFlow` where a `Party` and an optional externalId `UUID` are
   specified as parameters. An optional `PublicKey` parameter may be provided if 
   we we wish to store a mapping between a known `PublicKey` and the `Party`. The
   initiating party generates a ``ChallengeResponse`` and sends this to the counter-party
   who then generates a new key pair. The ``ChallengeResonse`` is signed over using
   the new ``PublicKey`` and sent back to the initiating party in the form of a 
   ``SignedKeyForAccount`` object. The ``ChallengeResponse``
   and signature are verified before registering the mapping between ``PublicKey`` and the
   counter-party's ``CordaX500NAme`` in the requesting parties``IdentityService``.
   
2. `SyncKeyMappings` which takes the following format:

    1. The initiator shares `AnonymousParty` objects for all parties involved
       in a confidential transaction.
    2. The responder tries to resolve each `AnonymousParty` to a `Party`.
       The parties which cannot be resolved are sent back to the initiator.
    3. The initiator sends back the `Party` objects for each `AnonymousParty`
       object which could not be looked up. The takes the form of a map,
       keyed with `AnonymousParty`s. The initiator cannot create a signed
       assertion that the mapping is correct. Instead, the responder must
       contact each `Party` individually and ask them for a signed assertion.
    4. The Responder asks each `Party` for a `SignedKeyForAccount`. The responders
       will return a `SignedDataKeyForAccount` if they own the key, otherwise, they'll
       return a `null`.
    5. The key difference to the old `SyncIdentitiesFlow` is that when we
       used certificates, the initiator of the flow could just send the
       certificate chains to the responder. Clearly this cannot happen in
       the absence of certificates stored for each CA. However, the upshot
       of this, is that now, only the creator of the confidential identity
       can prove they created it. Assertions made by other nodes are
       deniable.

The current flows can be left as they are. However my view is that they
should be deprecated.

#### New flow security protocol
<p align="center">
<<a href="https://ibb.co/bN1ndpj"><img src="https://i.ibb.co/nQrSkhq/ci-flow-security-protocol.png" alt="ci-flow-security-protocol" border="0"></a>