# Anonymous key mapping (Confidential identities changes)

## Overview

We are proposing a change to the identity service and key management services
to simplify the use of "confidential identities" (otherwise known as mapping
public keys to `Party`s) by:

* replacing the use of certificate chains with signed mappings of public
  keys to `Party`s

* eliminate a dependency on the `IdentityService` by the `BasicHSMKeyManagementService`

* eliminate the need for an `IdentityServiceInternal` interface; and,

The key motivation driving these changes is the accounts feature which is
due to be released in Corda 5.

We would like the design review board to review our proposed changes detailed
in this document and also review a PoC which has been put together by Will
Hester that implements the changes described in this document.

The intention is that we will target Corda 5 with these changes.

## Background

The "Confidential identities" feature was introduced so that node operators
could create new key pairs on a per transaction basis instead of repeatedly
using the "legal identity" key, which is well known. Inside transactions,
only public keys would be stored, instead of a public key and x500 name,
thus anonymising state participation.

In order for parties to gain assurance that they are transacting with the
correct counter-party keys, certificate chains -- which prove "ownership"
of a key to a node -- are created with each newly generated key pair and
shared with counter-parties.

With the certificate chain stored for a particular public key, node operators
can look-up which `Party` "owns" that key. This is required to check the
intended keys are being used.

### Simplification needed

The identity service code requires simplification:

Currently there are two identity service interfaces `IdentityService` and
`IdentityServiceInternal`. `IdentityService` is intended to be used by CorDapp
developers and `IdentityServiceInternal` is used by the current "confidential
identities" feature. Both interfaces can be merged together, simplifying
the API. Unfortunately the API does exist in a package named `net.corda.node.services.api`
implying that it's a public API, yet the name of it "Internal..." implies
it is not a public facing API. What's going on here?

The `PersistentIdentityService` and `InMemoryIdentityService` both contain
two maps:

1. `keysToParties` which is a mapping of `PublicKey` hash to the `Party`
   object for the legal/operator identity of a node.

2. `principalToParties` which maps an x500 name to a legal/operator
   identity. This map is currently only used for one operation, which is
   a `Party` lookup from some string by the shell (see `partiesFromName`).

Both maps are updated via the network map cache when a new `Party` is added
to the network and when a new "confidential identity" is created.

The network map driven updates to both maps are required. However, the updates
created to `principalToParties` when a new confidential identity is created
are unnecessary and shouldn't happen.

### Spurious dependencies

The persistent key management service implementation has a dependency on
the identity service.

For some reason, the `BasicHSMKeyManagementService` currently depends on
`IdentityServiceInternal` for some functionality to implement the `filterMyKeys`
function. However, as the `KeyManagementService` stores all the node's keys
this dependency is not required! This dependency can be removed, which will
simplify things at start-up a little.

### Unnecessary use of x.509 certificates

The confidential identities feature uses certificate chains when there is
no need for it to. Numerous customers have asked that we implement C/Is
without the PKI paraphernalia, which wastes space and increases the complexity
of the feature.

Furthermore, one of the objectives of the engineering team off-site was
to de-couple the node's identity from signing identities. With the current
model, there is an underlying assumption that all keys generated by a node
are for a single "legal identity" (and the current implementation of "confidential
identities" also implies this. However, this does not reflect likely real-world
deployments where only sufficiently "advanced" end-users will operate Corda
nodes. All other users will likely be using a Corda as a service whereby
a node operator hosts "accounts" for its users.

## Goals

* Deprecate the old certificate based APIs and remove mention of them from
  the docs.

* Add new simpler APIs which allow CorDapp developers to generate, verify
  and store signed mappings of public keys to x500 names.

* Write a new set of flows to request and share signed mappings of public
  keys to x500 names

* Document the new APIs.

* Refactor the identity management and key management services so that they
  are easier to understand and maintain.

* De-couple signing identities from the node operators identity.

## Non-goals

Accounts will be tackled as part of a separate piece of work.

## Timeline

1. DONE Figure out a rough approach.

2. DONE Write a PoC.

3. DONE Formalise a design.

4. TODO Get design reviewed by the DRB.

5. TODO Implement the design using the PoC as a basis.

6. TODO Review and merge the work for Corda 5.

## Requirements

Requirements for anonymous key mappings:

1. CorDapp developers need to be able to register that a public key is mapped
   to a particular node (`Party`). Both the node which creates the key and
   the `Party` which requested the key must be able to store the mapping.

2. Many keys should be mappable to one `Party` but many parties cannot be
   mapped to one key.

3. The party registering the key must be confident that the key has originated
   from the claimed node operator, otherwise messages may be routed to the
   wrong node or assets might be moved to incorrect keys, due to error or
   malicious intent.

4. Nodes must to be able to generate key pairs for multiple purposes; "confidential
   identity" for the node's legal identity, new key pairs for an "accounts".
   The key management service API should be generic.

5. Nodes must be able to lookup the `Party` for `AnonymousParty`s (i.e.
   just a `PublicKey`) that have an associated mapping. Nodes must be able
   to perform lookups for their own keys as well as other node's keys.

Use-cases:

1. Regular "confidential identities" as they are known today. This assumes
   a set up where the node operator is also the "legal identity" of the
   node and this legal identity wishes to partake in transactions using
   a public key other than their legal identity key.

2. Accounts. A minimum of one key pair must be associated with each account
   but it is more likely that multiple key pairs will be associated with
   a single account. Those key pairs should not be attributed to a single
   "legal identity" but instead the keys need to be mapped to a node operator
   so that their counterparties know where to route messages.

Assumptions:

1. Internal threats. Our threat model doesn't cover internal threats, so
   for the time being, the stored data structure which maps a `PublicKey`
   to a `Party` object is not signed.

## Design

### Data model & serialization impact and changes required.

No changes.

### Public API, backwards compatibility impact.

#### New public types

    @CordaSerializable
    data class KeyToPartyMapping(val key: PublicKey, val party: Party)

    @CordaSerializable
    data class SignedKeyToPartyMapping(
            val mapping: KeyToPartyMapping,
            val signature: DigitalSignature.WithKey
    )

The new type `KeyToPartyMapping` simply maps a `PublicKey` to a `Party`
object. The type makes no assumptions about _who_ the `PublicKey` is for.
Indeed, it could be for an account or a legal identity, if a company wishes
to self-host Corda. The `KeyToPartyMapping` should be signed by a node operator's
"legal identity" key only.

The `SignedKeyToPartyMapping` is intended to be:

1. Returned by the `KeyManagementService` when a particular method
   is called to generate a new signed `PublicKey`.

2. Ingested by the `IdentityService` to register a new `KeyToPartyMapping`.

It is unlikely that CorDapp developers will use these types directly. Instead,
there will be a set of flows for:

1. Requesting another node generate a new key pair then share a `SignedKeyToPartyMapping`.

2. Generating a new key pair, then sharing a `SignedKeyToPartyMapping` with
   another node.

####  `KeyManagementService` changes

`KeyManagementService` interface and implementation changes:

1. Remove the `PersistentIdentityService` as a dependency of the `BasicHSMKeyManagementService`.
   This means that the `filterMyKeys` method must use the `keysMap`. This
   is a one-line change. `AbstractNode` and some tests will also need to
   be updated.

2. Deprecate `freshKeyAndCert` methods because they are not required any
   more. Instead, CorDapp developers will use a new method which returns
   a `SignedPublicKeyToPartyMapping`.

3. Add a new API called `fun freshKey(externalID: UUID): SignedKeyToPartyMapping`
   which creates a new key pair, adds an entry to the `PublicKeyHashToExternalId`
   entity (if an externalId is specified) and returns a `SignedKeyToPartyMapping`.
   **Note:** that the `SignedKeyToPartyMapping` must be registered with the `IdentityService`
   separately. Failing to do this will result in your node being unable
   to resolve `AnonymousParty` objects to `Party` objects for unregistered
   `KeyToPartyMapping`s.

#### `PersistentIdentityService` changes

1. Retain the `principalToParties` map and ensure it is only updated when
   a new node is added to the network map cache. It doesn't need to be updated
   when new `SignedKeyToPartyMapping` are stored.

2. Retain the `keysToParties` map. However, as above, it should only be
   updated when a new `Party` is added to the network map cache. It doesn't
   need to be updated when new `SignedKeyToPartyMapping` are stored.

3. Add a new `AppendOnlyPersistentMap` called `keyToPartyMapping` which
   should contain **all** public keys mapped to the x500 name of the node
   where it is associated with. All legal identity keys as well as newly
   created anonymous keys should be stored in this map.

The `principalToParties` map and the `keysToParties` map are required because
the party information in the network map cache is ephemeral - parties can
be removed from the network map cache. This might happen if they leave the
network. Therefore, the legal identity key to party mapping data for old
parties is required to perform operations with data pertaining to parties
which were once on the network.

The `IdentityService` should always verify `SignedKeyToPartyMapping`s before
storing the mapping.

#### `IdentityService` changes

These points detail changes which must be made to ensure backwards compatible
behaviour whilst supporting a new API for key to party mappings:

1. Add a new method to `IdentityService` (and implementation in
   `PersistentIdentityService` and `InMemoryIdentityService`)

        fun registerPublicKeyToPartyMapping(mapping: SignedKeyToPartyMapping)

   which verifies and registers a `SignedKeyToPartyMapping`. This method
   only updates the `keyToPartyMapping` mapping. If a mapping has already
   been stored for the same `Party` then the method call is idempotent.
   If it turns out that another x500 name has been stored for the same key
   then the method will throw an exception for now. In the future, it might
   be the case that client-side generated key pairs can moved from one node
   to another or potentially used on multiple nodes. This work is out of
   scope for now - so the API will enforce that a public key can only ever
   be associated with a single x500 name.

2. `verifyAndRegisterIdentity` should now only be called by the network
   map cache. Registering new public key to party mappings (or "confidential
   identities") should be done using the new method outlined above.

3. `certificateFromKey` should return the `PartyAndCertificate` for
   any supplied `PublicKey`. This will require multiple map look-ups:

    1. On `KeyToPartyMapping`: `PublicKey` hash -> x500Name
    2. On `PrincipleToParty`: x500Name -> legal identity `PublicKey`
    3. On `keyToParties`: legal identity `PublicKey` to `PartyAndCertificate`

   Essentially we are trading performing an extra map lookup to storing
   the certificate chain for each confidential identity. Unfortunately we
   must store the certificate chains to preserve backwards compatibility,
   so the 3 map lookups are unavoidable.

4. `partyFromKey` should behave in the same way as `certificateFromKey`
   in that it should map "confidential identity" keys to `PartyAndCertificate`

5. `wellKnownPartyFromAnonymous` should work in the same way as `certificateFromKey`
   and `partyFromKey`.

Other methods shouldn't require any changes.

### Infrastructure services: persistence (schemas), messaging.

Adding a new hibernate entity which provides persistence for the `keyToPartyMapping`
append only persistent map.

### Impact on performance, scalability, high availability.

These changes should impact performance positively:

* Less disk space required for each newly generated key pair, as they
  are just stored as a public key hash to x500 name mapping in the
  `IdentityService`.
* Less heap space required as only one cert chain is stored for each
  legal identity key, as opposed to one cert chain _per_ key.
* We perform one extra map look-up for key to X look-ups on the `IdentityService`
  but as all this data is cached, the extra lookup shouldn't have a huge
  impact on performance.

### Versioning, upgradability, migration.

A database migration script will be required to populate the new hibernate
entity which backs the `keyToPartyMapping`. The existing "confidential identity"
mappings in the `keysToParties` entity must be moved to the `keyToPartyMapping`
entity. Once moved, they can be removed from the `keysToParties` table.
Furthermore, any non-legal identity key mappings in the `principalToParties`
can be removed, as they are not required.

### UI requirements, if any. Illustrate with UI Mockups and/or wireframes.

Keys with no mapping must be rendered as a substring of the public key.
Keys with mappings to an x500name can be rendered used the x500 name.

#### Flows

Three sets of flows will be added:

1. `RequestNewKey` where a `Party` and an optional externalId `UUID` are
   specified as parameters. The `Party` is then asked to generate a new
   key pair, then map the public key to it's own `Party` object. This mapping
   will then be stored locally and shared with the requesting node, which
   then verifies and stores the mapping.
2. `GenerateAndShareNewKey` which implements the above but in reverse. This
   flow requests a new key pair and key to `Party` mapping, stores the mapping
   then shares it with the specified `Party`s.
3. `SyncKeyMappings` which takes a transaction and shares mappings for
   all the `AnonymousParty` objects which the specified `Party` does not
   have a mapping for.






